var $hdTby$path = require("path");
var $hdTby$stream = require("stream");
var $hdTby$util = require("util");
var $hdTby$buffer = require("buffer");
var $hdTby$parcelcore = require("@parcel/core");
var $hdTby$parcelutils = require("@parcel/utils");
var $hdTby$parcelworkers = require("@parcel/workers");
var $hdTby$events = require("events");


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "ncp", () => $424a3d02b19046da$export$d3a8044e3fef7335);



var $e3bcaa4f4af38160$exports = {};

$parcel$export($e3bcaa4f4af38160$exports, "NodeFS", () => $e3bcaa4f4af38160$export$c4e0ef2ab73c21e7);
// $FlowFixMe[prop-missing] handled by the throwing constructor
class $e3bcaa4f4af38160$export$c4e0ef2ab73c21e7 {
    constructor(){
        throw new Error("NodeFS isn't available in the browser");
    }
}


var $f7144a04ec8d76c7$exports = {};

$parcel$export($f7144a04ec8d76c7$exports, "MemoryFS", () => $f7144a04ec8d76c7$export$3048eb7ec07c2c4e);
$parcel$export($f7144a04ec8d76c7$exports, "FSError", () => $f7144a04ec8d76c7$export$d414276624ebf134);
$parcel$export($f7144a04ec8d76c7$exports, "makeShared", () => $f7144a04ec8d76c7$export$df9eb3e75aa27a22);
$parcel$export($f7144a04ec8d76c7$exports, "File", () => $f7144a04ec8d76c7$export$b6afa8811b7e644e);




var $9c28dd2ee9e2ac99$exports = {};
$9c28dd2ee9e2ac99$exports = JSON.parse('{"name":"@parcel/fs","version":"2.12.0","description":"Blazing fast, zero configuration web application bundler","license":"MIT","publishConfig":{"access":"public"},"funding":{"type":"opencollective","url":"https://opencollective.com/parcel"},"repository":{"type":"git","url":"https://github.com/parcel-bundler/parcel.git"},"main":"lib/index.js","source":"src/index.js","types":"index.d.ts","engines":{"node":">= 12.0.0"},"targets":{"types":false,"main":{"includeNodeModules":{"@parcel/core":false,"@parcel/rust":false,"@parcel/types":false,"@parcel/utils":false,"@parcel/watcher":false,"@parcel/workers":false}},"browser":{"includeNodeModules":{"@parcel/core":false,"@parcel/rust":false,"@parcel/types":false,"@parcel/utils":false,"@parcel/watcher":false,"@parcel/workers":false}}},"scripts":{"build-ts":"mkdir -p lib && flow-to-ts src/types.js > lib/types.d.ts","check-ts":"tsc --noEmit index.d.ts"},"dependencies":{"@parcel/rust":"2.12.0","@parcel/types":"2.12.0","@parcel/utils":"2.12.0","@parcel/watcher":"^2.0.7","@parcel/workers":"2.12.0"},"devDependencies":{"graceful-fs":"^4.2.4","ncp":"^2.0.0","nullthrows":"^1.1.1","utility-types":"^3.10.0"},"peerDependencies":{"@parcel/core":"^2.12.0"},"browser":{"@parcel/fs":"./lib/browser.js","./src/NodeFS.js":"./src/NodeFS.browser.js"},"gitHead":"2059029ee91e5f03a273b0954d3e629d7375f986"}');



var $0be2f1d66c175af5$exports = {};
"use strict";
function $0be2f1d66c175af5$var$nullthrows(x, message) {
    if (x != null) return x;
    var error = new Error(message !== undefined ? message : "Got unexpected " + x);
    error.framesToPop = 1; // Skip nullthrows's own stack frame.
    throw error;
}
$0be2f1d66c175af5$exports = $0be2f1d66c175af5$var$nullthrows;
$0be2f1d66c175af5$exports.default = $0be2f1d66c175af5$var$nullthrows;
Object.defineProperty($0be2f1d66c175af5$exports, "__esModule", {
    value: true
});




function $a76a47717b367087$export$4c6d088a7d7f9947(fs, moduleName, dir) {
    let { root: root } = (0, ($parcel$interopDefault($hdTby$path))).parse(dir);
    while(dir !== root){
        // Skip node_modules directories
        if ((0, ($parcel$interopDefault($hdTby$path))).basename(dir) === "node_modules") dir = (0, ($parcel$interopDefault($hdTby$path))).dirname(dir);
        try {
            let moduleDir = (0, ($parcel$interopDefault($hdTby$path))).join(dir, "node_modules", moduleName);
            let stats = fs.statSync(moduleDir);
            if (stats.isDirectory()) return moduleDir;
        } catch (err) {
        // ignore
        }
        // Move up a directory
        dir = (0, ($parcel$interopDefault($hdTby$path))).dirname(dir);
    }
    return null;
}
function $a76a47717b367087$export$d51a93c758976388(fs, fileNames, dir, root) {
    let { root: pathRoot } = (0, ($parcel$interopDefault($hdTby$path))).parse(dir);
    // eslint-disable-next-line no-constant-condition
    while(true){
        if ((0, ($parcel$interopDefault($hdTby$path))).basename(dir) === "node_modules") return null;
        for (const fileName of fileNames){
            let filePath = (0, ($parcel$interopDefault($hdTby$path))).join(dir, fileName);
            try {
                if (fs.statSync(filePath).isFile()) return filePath;
            } catch (err) {
            // ignore
            }
        }
        if (dir === root || dir === pathRoot) break;
        dir = (0, ($parcel$interopDefault($hdTby$path))).dirname(dir);
    }
    return null;
}
function $a76a47717b367087$export$64df6e3182fd5b2d(fs, filePaths) {
    for (let filePath of filePaths)try {
        if (fs.statSync(filePath).isFile()) return filePath;
    } catch (err) {
    // ignore
    }
}



var $f7144a04ec8d76c7$require$Buffer = $hdTby$buffer.Buffer;
const $f7144a04ec8d76c7$var$instances = new Map();
let $f7144a04ec8d76c7$var$id = 0;
class $f7144a04ec8d76c7$export$3048eb7ec07c2c4e {
    _numWorkerInstances = 0;
    _workerRegisterResolves = [];
    _emitter = new (0, ($parcel$interopDefault($hdTby$events)))();
    constructor(workerFarm){
        this.farm = workerFarm;
        this._cwd = (0, ($parcel$interopDefault($hdTby$path))).resolve((0, ($parcel$interopDefault($hdTby$path))).sep);
        this.dirs = new Map([
            [
                this._cwd,
                new $f7144a04ec8d76c7$var$Directory()
            ]
        ]);
        this.files = new Map();
        this.symlinks = new Map();
        this.watchers = new Map();
        this.events = [];
        this.id = $f7144a04ec8d76c7$var$id++;
        this._workerHandles = [];
        this._eventQueue = [];
        $f7144a04ec8d76c7$var$instances.set(this.id, this);
        this._emitter.on("allWorkersRegistered", ()=>{
            for (let resolve of this._workerRegisterResolves)resolve();
            this._workerRegisterResolves = [];
        });
    }
    static deserialize(opts) {
        let existing = $f7144a04ec8d76c7$var$instances.get(opts.id);
        if (existing != null) {
            // Correct the count of worker instances since serialization assumes a new instance is created
            (0, ($parcel$interopDefault($hdTby$parcelworkers))).getWorkerApi().runHandle(opts.handle, [
                "decrementWorkerInstance",
                []
            ]);
            return existing;
        }
        let fs = new $f7144a04ec8d76c7$var$WorkerFS(opts.id, (0, (/*@__PURE__*/$parcel$interopDefault($0be2f1d66c175af5$exports)))(opts.handle));
        fs.dirs = opts.dirs;
        fs.files = opts.files;
        fs.symlinks = opts.symlinks;
        return fs;
    }
    serialize() {
        if (!this.handle) this.handle = this.farm.createReverseHandle((fn, args)=>{
            // $FlowFixMe
            return this[fn](...args);
        });
        // If a worker instance already exists, it will decrement this number
        this._numWorkerInstances++;
        return {
            $$raw: false,
            id: this.id,
            handle: this.handle,
            dirs: this.dirs,
            files: this.files,
            symlinks: this.symlinks
        };
    }
    decrementWorkerInstance() {
        this._numWorkerInstances--;
        if (this._numWorkerInstances === this._workerHandles.length) this._emitter.emit("allWorkersRegistered");
    }
    cwd() {
        return this._cwd;
    }
    chdir(dir) {
        this._cwd = dir;
    }
    _normalizePath(filePath, realpath = true) {
        filePath = (0, ($parcel$interopDefault($hdTby$path))).normalize(filePath);
        if (!filePath.startsWith(this.cwd())) filePath = (0, ($parcel$interopDefault($hdTby$path))).resolve(this.cwd(), filePath);
        // get realpath by following symlinks
        if (realpath) {
            let { root: root, dir: dir, base: base } = (0, ($parcel$interopDefault($hdTby$path))).parse(filePath);
            let parts = dir.slice(root.length).split((0, ($parcel$interopDefault($hdTby$path))).sep).concat(base);
            let res = root;
            for (let part of parts){
                res = (0, ($parcel$interopDefault($hdTby$path))).join(res, part);
                let symlink = this.symlinks.get(res);
                if (symlink) res = symlink;
            }
            return res;
        }
        return filePath;
    }
    async writeFile(filePath, contents, options) {
        filePath = this._normalizePath(filePath);
        if (this.dirs.has(filePath)) throw new $f7144a04ec8d76c7$export$d414276624ebf134("EISDIR", filePath, "is a directory");
        let dir = (0, ($parcel$interopDefault($hdTby$path))).dirname(filePath);
        if (!this.dirs.has(dir)) throw new $f7144a04ec8d76c7$export$d414276624ebf134("ENOENT", dir, "does not exist");
        let buffer = $f7144a04ec8d76c7$export$df9eb3e75aa27a22(contents);
        let file = this.files.get(filePath);
        let mode = options && options.mode || 438;
        if (file) {
            file.write(buffer, mode);
            this.files.set(filePath, file);
        } else this.files.set(filePath, new $f7144a04ec8d76c7$export$b6afa8811b7e644e(buffer, mode));
        await this._sendWorkerEvent({
            type: "writeFile",
            path: filePath,
            entry: this.files.get(filePath)
        });
        this._triggerEvent({
            type: file ? "update" : "create",
            path: filePath
        });
    }
    // eslint-disable-next-line require-await
    async readFile(filePath, encoding) {
        return this.readFileSync(filePath, encoding);
    }
    readFileSync(filePath, encoding) {
        filePath = this._normalizePath(filePath);
        let file = this.files.get(filePath);
        if (file == null) throw new $f7144a04ec8d76c7$export$d414276624ebf134("ENOENT", filePath, "does not exist");
        let buffer = file.read();
        if (encoding) return buffer.toString(encoding);
        return buffer;
    }
    async copyFile(source, destination) {
        let contents = await this.readFile(source);
        await this.writeFile(destination, contents);
    }
    statSync(filePath) {
        filePath = this._normalizePath(filePath);
        let dir = this.dirs.get(filePath);
        if (dir) return dir.stat();
        let file = this.files.get(filePath);
        if (file == null) throw new $f7144a04ec8d76c7$export$d414276624ebf134("ENOENT", filePath, "does not exist");
        return file.stat();
    }
    // eslint-disable-next-line require-await
    async stat(filePath) {
        return this.statSync(filePath);
    }
    readdirSync(dir, opts) {
        dir = this._normalizePath(dir);
        if (!this.dirs.has(dir)) throw new $f7144a04ec8d76c7$export$d414276624ebf134("ENOENT", dir, "does not exist");
        if (!dir.endsWith((0, ($parcel$interopDefault($hdTby$path))).sep)) dir += (0, ($parcel$interopDefault($hdTby$path))).sep;
        let res = [];
        for (let [filePath, entry] of this.dirs){
            if (filePath === dir) continue;
            if (filePath.startsWith(dir) && filePath.indexOf((0, ($parcel$interopDefault($hdTby$path))).sep, dir.length) === -1) {
                let name = filePath.slice(dir.length);
                if (opts?.withFileTypes) res.push(new $f7144a04ec8d76c7$var$Dirent(name, entry));
                else res.push(name);
            }
        }
        for (let [filePath, entry] of this.files)if (filePath.startsWith(dir) && filePath.indexOf((0, ($parcel$interopDefault($hdTby$path))).sep, dir.length) === -1) {
            let name = filePath.slice(dir.length);
            if (opts?.withFileTypes) res.push(new $f7144a04ec8d76c7$var$Dirent(name, entry));
            else res.push(name);
        }
        for (let [from] of this.symlinks)if (from.startsWith(dir) && from.indexOf((0, ($parcel$interopDefault($hdTby$path))).sep, dir.length) === -1) {
            let name = from.slice(dir.length);
            if (opts?.withFileTypes) res.push(new $f7144a04ec8d76c7$var$Dirent(name, {
                mode: $f7144a04ec8d76c7$var$S_IFLNK
            }));
            else res.push(name);
        }
        return res;
    }
    // eslint-disable-next-line require-await
    async readdir(dir, opts) {
        return this.readdirSync(dir, opts);
    }
    async unlink(filePath) {
        filePath = this._normalizePath(filePath);
        if (!this.files.has(filePath) && !this.dirs.has(filePath)) throw new $f7144a04ec8d76c7$export$d414276624ebf134("ENOENT", filePath, "does not exist");
        this.files.delete(filePath);
        this.dirs.delete(filePath);
        this.watchers.delete(filePath);
        await this._sendWorkerEvent({
            type: "unlink",
            path: filePath
        });
        this._triggerEvent({
            type: "delete",
            path: filePath
        });
        return Promise.resolve();
    }
    async mkdirp(dir) {
        dir = this._normalizePath(dir);
        if (this.dirs.has(dir)) return Promise.resolve();
        if (this.files.has(dir)) throw new $f7144a04ec8d76c7$export$d414276624ebf134("ENOENT", dir, "is not a direc