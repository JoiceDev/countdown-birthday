"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _graph() {
  const data = require("@parcel/graph");
  _graph = function () {
    return data;
  };
  return data;
}
function _assert() {
  const data = _interopRequireDefault(require("assert"));
  _assert = function () {
    return data;
  };
  return data;
}
function _plugin() {
  const data = require("@parcel/plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@parcel/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));
  _nullthrows = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _diagnostic() {
  const data = require("@parcel/diagnostic");
  _diagnostic = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Default options by http version.
const HTTP_OPTIONS = {
  '1': {
    minBundles: 1,
    manualSharedBundles: [],
    minBundleSize: 30000,
    maxParallelRequests: 6,
    disableSharedBundles: false
  },
  '2': {
    minBundles: 1,
    manualSharedBundles: [],
    minBundleSize: 20000,
    maxParallelRequests: 25,
    disableSharedBundles: false
  }
};

/* BundleRoot - An asset that is the main entry of a Bundle. */

const dependencyPriorityEdges = {
  sync: 1,
  parallel: 2,
  lazy: 3
};

// IdealGraph is the structure we will pass to decorate,
// which mutates the assetGraph into the bundleGraph we would
// expect from default bundler
/**
 *
 * The Bundler works by creating an IdealGraph, which contains a BundleGraph that models bundles
 * connected to other bundles by what references them, and thus models BundleGroups.
 *
 * First, we enter `bundle({bundleGraph, config})`. Here, "bundleGraph" is actually just the
 * assetGraph turned into a type `MutableBundleGraph`, which will then be mutated in decorate,
 * and turned into what we expect the bundleGraph to be as per the old (default) bundler structure
 *  & what the rest of Parcel expects a BundleGraph to be.
 *
 * `bundle({bundleGraph, config})` First gets a Mapping of target to entries, In most cases there is
 *  only one target, and one or more entries. (Targets are pertinent in monorepos or projects where you
 *  will have two or more distDirs, or output folders.) Then calls create IdealGraph and Decorate per target.
 *
 */
var _default = exports.default = new (_plugin().Bundler)({
  loadConfig({
    config,
    options,
    logger
  }) {
    return loadBundlerConfig(config, options, logger);
  },
  bundle({
    bundleGraph,
    config,
    logger
  }) {
    let targetMap = getEntryByTarget(bundleGraph); // Organize entries by target output folder/ distDir
    let graphs = [];
    for (let entries of targetMap.values()) {
      // Create separate bundleGraphs per distDir
      graphs.push(createIdealGraph(bundleGraph, config, entries, logger));
    }
    for (let g of graphs) {
      decorateLegacyGraph(g, bundleGraph); //mutate original graph
    }
  },

  optimize() {}
});
function decorateLegacyGraph(idealGraph, bundleGraph) {
  let idealBundleToLegacyBundle = new Map();
  let {
    bundleGraph: idealBundleGraph,
    dependencyBundleGraph,
    bundleGroupBundleIds,
    manualAssetToBundle
  } = idealGraph;
  let entryBundleToBundleGroup = new Map();
  // Step Create Bundles: Create bundle groups, bundles, and shared bundles and add assets to them
  for (let [bundleNodeId, idealBundle] of idealBundleGraph.nodes.entries()) {
    if (!idealBundle || idealBundle === 'root') continue;
    let entryAsset = idealBundle.mainEntryAsset;
    let bundleGroups = [];
    let bundleGroup;
    let bundle;
    if (bundleGroupBundleIds.has(bundleNodeId)) {
      (0, _assert().default)(idealBundle.manualSharedBundle == null, 'Unstable Manual Shared Bundle feature is processing a manualSharedBundle as a BundleGroup');
      let dependencies = dependencyBundleGraph.getNodeIdsConnectedTo(dependencyBundleGraph.getNodeIdByContentKey(String(bundleNodeId)), _graph().ALL_EDGE_TYPES).map(nodeId => {
        let dependency = (0, _nullthrows().default)(dependencyBundleGraph.getNode(nodeId));
        (0, _assert().default)(dependency.type === 'dependency');
        return dependency.value;
      });
      (0, _assert().default)(entryAsset != null, 'Processing a bundleGroup with no entry asset');
      for (let dependency of dependencies) {
        bundleGroup = bundleGraph.createBundleGroup(dependency, idealBundle.target);
        bundleGroups.push(bundleGroup);
      }
      (0, _assert().default)(bundleGroup);
      entryBundleToBundleGroup.set(bundleNodeId, bundleGroup);
      bundle = (0, _nullthrows().default)(bundleGraph.createBundle({
        entryAsset: (0, _nullthrows().default)(entryAsset),
        needsStableName: idealBundle.needsStableName,
        bundleBehavior: idealBundle.bundleBehavior,
        target: idealBundle.target,
        manualSharedBundle: idealBundle.manualSharedBundle
      }));
      bundleGraph.addBundleToBundleGroup(bundle, bundleGroup);
    } else if (idealBundle.sourceBundles.size > 0 && !idealBundle.mainEntryAsset) {
      let uniqueKey = idealBundle.uniqueKey != null ? idealBundle.uniqueKey : [...idealBundle.assets].map(asset => asset.id).join(',');
      bundle = (0, _nullthrows().default)(bundleGraph.createBundle({
        uniqueKey,
        needsStableName: idealBundle.needsStableName,
        bundleBehavior: idealBundle.bundleBehavior,
        type: idealBundle.type,
        target: idealBundle.target,
        env: idealBundle.env,
        manualSharedBundle: idealBundle.manualSharedBundle
      }));
    } else if (idealBundle.uniqueKey != null) {
      bundle = (0, _nullthrows().default)(bundleGraph.createBundle({
        uniqueKey: idealBundle.uniqueKey,
        needsStableName: idealBundle.needsStableName,
        bundleBehavior: idealBundle.bundleBehavior,
        type: idealBundle.type,
        target: idealBundle.target,
        env: idealBundle.env,
        manualSharedBundle: idealBundle.manualSharedBundle
      }));
    } else {
      (0, _assert().default)(entryAsset != null);
      bundle = (0, _nullthrows().default)(bundleGraph.createBundle({
        entryAsset,
        needsStableName: idealBundle.needsStableName,
        bundleBehavior: idealBundle.bundleBehavior,
        target: idealBundle.target,
        manualSharedBundle: idealBundle.manualSharedBundle
      }));
    }
    idealBundleToLegacyBundle.set(idealBundle, bundle);
    for (let asset of idealBundle.assets) {
      bundleGraph.addAssetToBundle(asset, bundle);
    }
  }
  // Step Internalization: Internalize dependencies for bundles
  for (let idealBundle of idealBundleGraph.nodes) {
    if (!idealBundle || idealBundle === 'root') continue;
    let bundle = (0, _nullthrows().default)(idealBundleToLegacyBundle.get(idealBundle));
    if (idealBundle.internalizedAssets) {
      idealBundle.internalizedAssets.forEach(internalized => {
        let incomingDeps = bundleGraph.getIncomingDependencies(idealGraph.assets[internalized]);
        for (let incomingDep of incomingDeps) {
          if (incomingDep.priority === 'lazy' && incomingDep.specifierType !== 'url' && bundle.hasDependency(incomingDep)) {
            bundleGraph.internalizeAsyncDependency(bundle, incomingDep);
          }
        }
      });
    }
  }
  // Unstable Manual Shared Bundles
  // NOTE: This only works under the assumption that manual shared bundles would have
  // always already been loaded before the bundle that requires internalization.
  for (let manualSharedAsset of manualAssetToBundle.keys()) {
    let incomingDeps = bundleGraph.getIncomingDependencies(manualSharedAsset);
    for (let incomingDep of incomingDeps) {
      if (incomingDep.priority === 'lazy' && incomingDep.specifierType !== 'url') {
        let bundles = bundleGraph.getBundlesWithDependency(incomingDep);
        for (let bundle of bundles) {
          bundleGraph.internalizeAsyncDependency(bundle, incomingDep);
        }
      }
    }
  }

  // Step Add to BundleGroups: Add bundles to their bundle groups
  idealBundleGraph.traverse((nodeId, _, actions) => {
    let node = idealBundleGraph.getNode(nodeId);
    if (node === 'root') {
      return;
    }
    actions.skipChildren();
    let outboundNodeIds = idealBundleGraph.getNodeIdsConnectedFrom(nodeId);
    let entryBundle = (0, _nullthrows().default)(idealBundleGraph.getNode(nodeId));
    (0, _assert().default)(entryBundle !== 'root');
    let legacyEntryBundle = (0, _nullthrows().default)(idealBundleToLegacyBundle.get(entryBundle));
    for (let id of outboundNodeIds) {
      let siblingBundle = (0, _nullthrows().default)(idealBundleGraph.getNode(id));
      (0, _assert().default)(siblingBundle !== 'root');
      let legacySiblingBundle = (0, _nullthrows().default)(idealBundleToLegacyBundle.get(siblingBundle));
      bundleGraph.createBundleReference(legacyEntryBundle, legacySiblingBundle);
    }
  });

  // Step References: Add references to all bundles
  for (let [asset, references] of idealGraph.assetReference) {
    for (let [dependency, bundle] of references) {
      let legacyBundle = (0, _nullthrows().default)(idealBundleToLegacyBundle.get(bundle));
      bundleGraph.createAssetReference(dependency, asset, legacyBundle);
    }
  }
  for (let {
    from,
    to
  } of idealBundleGraph.getAllEdges()) {
    let sourceBundle = (0, _nullthrows().default)(idealBundleGraph.getNode(from));
    if (sourceBundle === 'root') {
      continue;
    }
    (0, _assert().default)(sourceBundle !== 'root');
    let legacySourceBundle = (0, _nullthrows().default)(idealBundleToLegacyBundle.get(sourceBundle));
    let targetBundle = (0, _nullthrows().default)(idealBundleGraph.getNode(to));
    if (targetBundle === 'root') {
      continue;
    }
    (0, _assert().default)(targetBundle !== 'root');
    let legacyTargetBundle = (0, _nullthrows().default)(idealBundleToLegacyBundle.get(targetBundle));
    bundleGraph.createBundleReference(legacySourceBundle, legacyTargetBundle);
  }
}
function createIdealGraph(assetGraph, config, entries, logger) {
  // Asset to the bundle and group it's an entry of
  let bundleRoots = new Map();
  let bundles = new Map();
  let dependencyBundleGraph = new (_graph().ContentGraph)();
  let assetReference = new (_utils().DefaultMap)(() => []);

  // A Graph of Bundles and a root node (dummy string), which models only Bundles, and connections to their
  // referencing Bundle. There are no actual BundleGroup nodes, just bundles that take on that role.
  let bundleGraph = new (_graph().Graph)();
  let stack = [];
  let bundleRootEdgeTypes = {
    parallel: 1,
    lazy: 2
  };
  // Graph that models bundleRoots, with parallel & async deps only to inform reachability
  let bundleRootGraph = new (_graph().Graph)();
  let assetToBundleRootNodeId = new Map();
  let bundleGroupBundleIds = new Set();
  let bundleGraphRootNodeId = (0, _nullthrows().default)(bundleGraph.addNode('root'));
  bundleGraph.setRootNodeId(bundleGraphRootNodeId);
  // Step Create Entry Bundles
  for (let [asset, dependency] of entries) {
    let bundle = createBundle({
      asset,
      target: (0, _nullthrows().default)(dependency.target),
      needsStableName: dependency.isEntry
    });
    let nodeId = bundleGraph.addNode(bundle);
    bundles.set(asset.id, nodeId);
    bundleRoots.set(asset, [nodeId, nodeId]);
    bundleGraph.addEdge(bundleGraphRootNodeId, nodeId);
    dependencyBundleGraph.addEdge(dependencyBundleGraph.addNodeByContentKeyIfNeeded(dependency.id, {
      value: dependency,
      type: 'dependency'
    }), dependencyBundleGraph.addNodeByContentKeyIfNeeded(String(nodeId), {
      value: bundle,
      type: 'bundle'
    }), dependencyPriorityEdges[dependency.priority]);
    bundleGroupBundleIds.add(nodeId);
  }
  let assets = [];
  let assetToIndex = new Map();
  //Manual is a map of the user-given name to the bundle node Id that corresponds to ALL the assets that match any glob in that user-specified array
  let manualSharedMap = new Map();
  // May need a map to be able to look up NON- bundle root assets which need special case instructions
  // Use this when placing assets into bundles, to avoid duplication
  let manualAssetToBundle = new Map();
  let {
    manualAssetToConfig,
    constantModuleToMSB
  } = function makeManualAssetToConfigLookup() {
    let manualAssetToConfig = new Map();
    let constantModuleToMSB = new (_utils().DefaultMap)(() => []);
    if (config.manualSharedBundles.length === 0) {
      return {
        manualAssetToConfig,
        constantModuleToMSB
      };
    }
    let parentsToConfig = new (_utils().DefaultMap)(() => []);
    for (let c of config.manualSharedBundles) {
      if (c.root != null) {
        parentsToConfig.get(_path().default.join(config.projectRoot, c.root)).push(c);
      }
    }
    let numParentsToFind = parentsToConfig.size;
    let configToParentAsset = new Map();
    assetGraph.traverse((node, _, actions) => {
      if (node.type === 'asset' && parentsToConfig.has(node.value.filePath)) {
        for (let c of parentsToConfig.get(node.value.filePath)) {
          configToParentAsset.set(c, node.value);
        }
        numParentsToFind--;
        if (numParentsToFind === 0) {
          // If we've found all parents we can stop traversal
          actions.stop();
        }
      }
    });

    // Process in reverse order so earlier configs take precedence
    for (let c of config.manualSharedBundles.reverse()) {
      if (c.root != n